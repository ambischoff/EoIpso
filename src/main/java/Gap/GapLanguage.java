package Gap;

import static java.nio.charset.StandardCharsets.UTF_8;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.TreeMap;

import Helper.Encoding.Encoding;
import Helper.Encoding.EncodingDetector;
import Helper.Language.Language;
import Helper.Language.Method;
import Helper.Log.Logging;
import Helper.Typology.ArticulatoryPhonetics;

/**
 * implements the gap approach
 * 
 * @author abischoff
 *
 */
public class GapLanguage extends Language {

	private HashMap<String,String[]> phonetic = new HashMap<String,String[]>(); // m -> [labial, ...]
	private ArrayList<String[]> resultIPA = new ArrayList<String[]>();
	private int round;
	
	/**
	 * only for tests
	 * @param args
	 */
	public static void main(String[] args) {
		@SuppressWarnings("unused")
		GapLanguage lang = new GapLanguage("Test",".\\data\\rawData\\Merkmalsphonetik\\Distinktiv\\Merkmalsphonetik_Indogermanisch_Distinktiv");
		lang.setIteration(100);
		lang.start();
	}
	
	/**
	 * starts the process
	 * @param name	language name
	 * @param file	file path
	 * @param iter	number of iterations
	 */
	public GapLanguage(String name, String file) {
		super(name,file);
		super.setIteration(50);
		this.round = 50;
		super.setThreshold(0.01);
	}

	/**
	 * Getter for the method
	 */
	public Method getMethod() {
		return Method.gap;
	}
	
	/**
	 * starts the process
	 */
	public void start() {
		String phoneticFile = "";
		if (this.file.contains("Merkmalsphonetik")) {
			phoneticFile = this.file;
		} else {
			this.makeMerkmalsphonetik(this.file);
		}
		Logging.debug("Read file...");
		this.readFile(phoneticFile);
		Logging.debug("Start gap approach...");
		this.gapMethod();
		if (this.getTypological()) {
			Logging.debug("Read typological information...");
			this.typology();
		}
	}
	
	/**
	 * creates a file for a language containing its sounds and distinctive features
	 * @param file	file path
	 * @return the path of the result file
	 */
	private String makeMerkmalsphonetik(String file) {
		
		ArrayList<String> alphabet = new ArrayList<String>();
		
		try {

			EncodingDetector e = new EncodingDetector(new FileInputStream(new File(file)), Encoding.UTF8);
			String encoding = e.getEncoding().toString();
			BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(file), encoding));
			if (!new File(".\\data").exists()) {
				new File(".\\data").mkdir();
			}
			if (!new File(".\\data\\transData").exists()) {
				new File(".\\data\\transData").mkdir();
			}
			BufferedWriter bw = new BufferedWriter( new OutputStreamWriter( new FileOutputStream(".\\data\\transData\\Merkmalphonetik_"+this.lang+".txt") , UTF_8));

			String line = br.readLine();
			//Entferne BOM falls vorhanden
			if (!line.contentEquals("") && line.toCharArray()[0] == 65279) {
				line = line.substring(1);
			}

			while (line != null) {
				String[] letters = line.split("\\s");
				for (String myLetter : letters) {
					if (!alphabet.contains(myLetter)) {
						alphabet.add(myLetter);
					}
				}
				line = br.readLine();
			}
				
			br.close();
			int count = 1;
			ArticulatoryPhonetics.setMethod("Gap");
			for (String letter :alphabet) {
				
				String[] feats = ArticulatoryPhonetics.getFeaturesOf(letter);

				StringBuilder sb = new StringBuilder();
				for (String feat : feats) {
					sb.append("\t"+feat);
				}
				
				bw.write(count + "\t"+letter + sb +"\r\n");
				count++;
			}
			
			bw.close();
			file = ".\\data\\transData\\Merkmalphonetik_"+this.lang+".txt";
		} catch (IOException e) {
			Logging.error(e.getLocalizedMessage());
		}
		return file;
	}
	
	/**
	 * reads the file generated by makeMerkmalsphonetik()
	 * @param file input file
	 */
	public void readFile(String file) {
		
		try {
			FileInputStream ldd = new FileInputStream(new File(file));
			
			EncodingDetector e = new EncodingDetector(ldd, Encoding.UTF8);
			String encoding = e.getEncoding().toString();
			e.close();
			BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(file), encoding));
			String line = br.readLine();
			//ignore BOM if it exists
			if (line.toCharArray()[0] == 65279) {
				line = line.substring(1);
			}

			while (line != null) {
				line = line.replaceFirst("^.*?\\t", "");
				if (!line.startsWith("	")) {
					this.phonetic.put(line.split("\\t")[0], line.replaceFirst("^.*?\\t", "").split("\\s"));		
				}
				line = br.readLine();
			}
				
			br.close();
			
		} catch (IOException e) {
			Logging.error(e.getLocalizedMessage());
		} 

			
	}
	
	/**
	 * executes the gap approach
	 * creates an ideal system
	 */
	public void gapMethod() {

		try {
			if (!new File(".\\result").exists()) {
				new File(".\\result").mkdir();
			}
			if (!new File(".\\result\\gap").exists()) {
				new File(".\\result\\gap").mkdir();
			}
			if (!new File(".\\result\\gap\\"+this.lang+"\\").exists()) {
				new File(".\\result\\gap\\"+this.lang+"\\").mkdir();
				Logging.debug("Generated directory result\\gap\\"+this.lang);
			}
			BufferedWriter bw2 = new BufferedWriter( new OutputStreamWriter( new FileOutputStream(".\\result\\gap\\"+this.lang+"\\ResultGap.txt") , UTF_8));

		/*
		 * creates phonetic symmetry
		 */
	
		while (round != 0) {
			Logging.debug(round + ". iteration");
			@SuppressWarnings("unchecked")
			IdealPhonemeSystem system = new IdealPhonemeSystem((HashMap<String,String[]>)phonetic.clone());

			for (String letter1 : phonetic.keySet()) {
				for (String letter2 : phonetic.keySet()) {
					ArrayList<String> letter1List = new ArrayList<String>(Arrays.asList(phonetic.get(letter1)));
					letter1List.removeAll(Arrays.asList(phonetic.get(letter2)));
					int schnitt1 = letter1List.size();
		
					ArrayList<String> letter1List2 = new ArrayList<String>(Arrays.asList(phonetic.get(letter1)));
					ArrayList<String> letter2List = new ArrayList<String>(Arrays.asList(phonetic.get(letter2)));
					letter2List.removeAll(letter1List2);
					int schnitt2 = letter2List.size();
		
					if ((schnitt1 == schnitt2) && (schnitt1 == 1)) {
						system.put(letter1List.get(0), letter2List.get(0), letter1, letter2);
					}
					
				}
			}
			
			phonetic = system.makeIdeal();
			if (phonetic == null) {
				break;
			}
			bw2.write((round-(iteration+1))*-1 + ". " + system.getResult()+"\r\n");
			resultIPA.add(system.getSoundPair());
			round--;
		}
		
		bw2.close();
		Logging.debug("Result file generated.");
		
		} catch (IOException e) {
			Logging.error(e.getLocalizedMessage());
		}
	}

	/**
	 * integrates typological information from Brown et al.
	 */
	public void typology() {

		TreeMap<Double,ArrayList<String>> result = new TreeMap<Double,ArrayList<String>>();				
		/*
		 * IPA2ASJP
		 * needed because Brown et al. does not use IPA
		 */

			for (String[] myCorr : this.resultIPA) {
				double value = Helper.Typology.Brown.getTypoProbablity(myCorr[0], myCorr[1]);
				if (result.containsKey(value)) {
					ArrayList<String> arr = result.get(value);
					arr.add(myCorr[0] + "\t>\t" + myCorr[1]);
					result.put(value, arr);
				} else {
					ArrayList<String> arr = new ArrayList<String>();
					arr.add(myCorr[0] + "\t>\t" + myCorr[1]);
					result.put(value, arr);
				}
				
			}
			try {
			//print
			
			BufferedWriter bw = new BufferedWriter( new OutputStreamWriter( new FileOutputStream(".\\result\\gap\\"+this.lang+"\\ResultGapWithTypology.txt") , UTF_8));
			for (Double d : result.descendingKeySet()) {
				for (String pair : result.get(d)) {
					if (d >= this.threshold)
						bw.write(d+"\t"+pair+"\r\n");
				}
			}
			bw.close();
		} catch (IOException e) {
			Logging.error(e.getLocalizedMessage());
		}
		

		
	}

	/**
	 * returns the path of the result file
	 * @return the path of the result file
	 */
	@Override
	public String getResultFile() {
		if (this.getTypological()) {
			return ".\\result\\gap\\"+this.lang+"\\ResultGapWithTypology.txt";
		}
		return ".\\result\\gap\\"+this.lang+"\\ResultGap.txt";
	}
	
}
